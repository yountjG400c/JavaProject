/**
 * 
 */
package com.ohio.ofcc.homework.calc.impl;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import com.ohio.ofcc.homework.calc.IFeeCalculator;
import com.ohio.ofcc.homework.util.FeeUtil;

/**
 * @author John_M_Yount
 *
 */
public class FeeCalculatorImpl implements IFeeCalculator {

	/* (non-Javadoc)
	 * @see com.ohio.ofcc.homework.calc.IFeeCalculator#calculateFee(int, int)
	 */
	@Override
	public float calculateFee(float invoiceAmt, int useCase, Map<Integer, Integer> arbCritMap) 
	{
		
		float retVal = 0;
		float costBasis = 0;
		
		switch (useCase)
		{
			case 1: retVal = calculateFeeCase1(invoiceAmt);
			case 2: retVal = calculateFeeCase2(invoiceAmt);
			case 3: {
				if(null ==  arbCritMap){
					retVal = calculateFeeCase2(invoiceAmt);					
				}else{
					retVal = calculateFeeCase2(invoiceAmt,arbCritMap);
				}				
			}
			case 4: retVal = calculateFeeCase4(invoiceAmt, costBasis);
			
		}
		
		
		return retVal;
	}
	
	@Override
	public float calculateFee(float invoiceAmt, int useCase){
		return calculateFee(invoiceAmt, useCase, null); 
	}
	
	public float calculateFeeCase1(float invoiceAmt)
	{
		float retVal = 0;
		
		float percent1 = (20/100);
		float percent2 = (10/100);
		float percent3 = (5/100);
		
		int lowRange = 100000;
		int midRange = 200000;
		int highRange = 500000;
		
		if(invoiceAmt <= lowRange)
		{
			retVal = (invoiceAmt * percent1);
		} else {
			retVal = (20000 + ((invoiceAmt - lowRange) * percent2));
		}		
		
		return retVal;
		
	}
	
	public float calculateFeeCase2(float invoiceAmt)
	{
		float retVal = 0;
		
		float percent1 = (20/100);
		float percent2 = (10/100);
		float percent3 = (5/100);
		
		int lowRange = 100000;
		int midRange = 200000;
		int highRange = 500000;
		
		if(invoiceAmt <= highRange){
			retVal = calculateFeeCase1(invoiceAmt);			
		} else {
			retVal = calculateFeeCase1(highRange);
			retVal = retVal + ((invoiceAmt - highRange) * percent3);
		}
		
		return retVal;
		
	}
	
	/**
	 * This method caluculates arbitrary ranges.
	 * @param invoiceAmt
	 * @param rangeCriteria (key- invoiceCeiling and value- invoiceRate)
	 * @return
	 */
	public float calculateFeeCase2(float invoiceAmt, Map<Integer, Integer> rangeCriteria)
	{
		float retVal = 0;
		int prevCeiling = 0;
		Set<Integer> invoiceCeilingSet = rangeCriteria.keySet();
		TreeSet<Integer> sortedInvoiceCeiling = new TreeSet<Integer>(invoiceCeilingSet);
		for(Integer invoiceCeiling:sortedInvoiceCeiling){
			if(invoiceAmt<=invoiceCeiling){
				retVal = retVal + ((invoiceAmt-prevCeiling) * (rangeCriteria.get(invoiceCeiling))/100);
				
			}else{
				retVal = retVal + (invoiceCeiling * (rangeCriteria.get(invoiceCeiling)/100));
			}
			prevCeiling = invoiceCeiling;
		}
		return retVal;
		
	}
	
	
	
	public float calculateFeeCase4(float invoiceAmt, float costBasis)
	{
		float percent1 = (20/100);
		float percent2 = (10/100);
		float percent3 = (5/100);
		
		int lowRange = 100000;
		int midRange = 200000;
		int highRange = 500000;
		
		float retVal = 0;
		float amtTotal = invoiceAmt+costBasis;
		if(amtTotal <= highRange){
			
				if(invoiceAmt <= lowRange)
				{
					retVal = (invoiceAmt * percent1);
				} else {
					retVal = (20000 + ((invoiceAmt - lowRange) * percent2));
				}		
				
		} else {
			retVal = calculateFeeCase1(highRange);
			retVal = retVal + ((invoiceAmt - highRange) * percent3);
		}
		return retVal;
		
	}
	
	

}
